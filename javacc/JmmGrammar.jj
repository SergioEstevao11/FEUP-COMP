PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;


SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
		<IMPORT: "import">

    |   < INT: "int" >
    |   < BOOLEAN: "boolean" >
    |   < INTBRACKETS: "int[]">
    |   < STRING: "String" >

    |   < COMMA: "," >
    |   < DOT: ".">
    |   < COLON: ":" >
    |   < SEMICOLON: ";" >
    |   < OPEN_SQUARE_BRACKET: "[">
    |   < CLOSE_SQUARE_BRACKET: "]">
    |   < OPEN_CURVE_BRACKET: "(">
    |   < CLOSE_CURVE_BRACKET: ")">
    |   < OPENBRACKET: "{">
    |   < CLOSEBRACKET: "}">

    |   < CLASS: "class">
    |   < PUBLIC: "public">
    |   < STATIC: "static">
    |   < VOID: "void">
    |   < MAIN: "main">
    |   < PRINTLN: "System.out.println" >
    |   < THIS: "this" >
    |   < EXTENDS: "extends" >
    |   < RETURN: "return" >
    |   < LENGTH: "length">
    |   < NEW: "new">

    |   < TRUE: "true">
    |   < FALSE: "false">
    |   < NOT: "!">
    |   < AND: "&&">
    |   < LESS: "<" >
    |   < PLUS: "+">
    |   < MINUS: "-">
    |   < TIMES: "*">
    |   < DIVIDE: "/">
    |   < EQUALS: "=">


    |   < IF: "if">
    |   < ELSE: "else">
    |   < WHILE: "while">

    |   < IDENTIFIER:  ("$" | <LETTER>) ("_" | "$" | <LETTER> | <DIGIT> | <UNDERSCORE>)*
                     | ("_" ("_" | "$" | <LETTER> | <DIGIT> | <UNDERSCORE>)+) >
    |   < LETTER: ["a"-"z","A"-"Z"] >
    |   < UNDERSCORE: "_" >
    |   < INTEGERLITERAL: (<DIGIT>)+ >
    |   < DIGIT: ["0"-"9"] >
    ;


Start : ImportDeclaration ClassDeclaration <EOF>
;

ImportDeclaration : (<IMPORT> <IDENTIFIER> ( <DOT> <IDENTIFIER> )* <SEMICOLON>)*
;

ClassDeclaration : <CLASS> <IDENTIFIER> [( <EXTENDS> <IDENTIFIER> )] <OPENBRACKET> ( VarDeclaration )* (MethodDeclaration)* <CLOSEBRACKET>
;

VarDeclaration : Type <IDENTIFIER> <SEMICOLON>
;

Type :  <INTBRACKETS> | 
        <INT> <OPEN_SQUARE_BRACKET> <IDENTIFIER> <CLOSE_SQUARE_BRACKET> |
        <BOOLEAN> |
        <STRING>
;

MethodDeclaration : <PUBLIC> (CommonMethodHeader | MainMethodHeader) <OPENBRACKET> MethodBody <CLOSEBRACKET>
;

CommonMethodHeader : Type <IDENTIFIER> <OPEN_CURVE_BRACKET> [( Type <IDENTIFIER> (<COMMA> Type <IDENTIFIER>)* )] <CLOSE_CURVE_BRACKET>
;

MainMethodHeader : <STATIC> <VOID> <MAIN> <OPEN_CURVE_BRACKET> <STRING> <OPEN_SQUARE_BRACKET> <CLOSE_SQUARE_BRACKET> <IDENTIFIER> <CLOSE_CURVE_BRACKET>
;

MethodBody : (VarDeclaration | Statement)* <RETURN> AndDeclaration <SEMICOLON>
;

Statement : <OPENBRACKET> (Statement)* <CLOSEBRACKET> |
            IfStatement |
            WhileStatement | 
            SCAN 2 AndDeclaration <SEMICOLON> |
            SCAN 2 Assignment
;

IfStatement : <IF> <OPEN_CURVE_BRACKET> AndDeclaration <CLOSE_CURVE_BRACKET> Statement <ELSE> Statement
;

WhileStatement : <WHILE> <OPEN_CURVE_BRACKET> AndDeclaration <CLOSE_CURVE_BRACKET> Statement
;

Assignment : VarAccess <EQUALS> AndDeclaration <SEMICOLON>      
;

VarAccess : SCAN 2 <IDENTIFIER> <OPEN_SQUARE_BRACKET> AndDeclaration <CLOSE_SQUARE_BRACKET> |
            <IDENTIFIER>
;


AndDeclaration : LessDeclaration (<AND> LessDeclaration)*
;
LessDeclaration : AddSubDeclaration (<LESS> AddSubDeclaration)*
;
AddSubDeclaration : MultDivDeclaration (<PLUS> MultDivDeclaration | <MINUS> MultDivDeclaration)*
;
MultDivDeclaration : NotDeclaration (<TIMES> NotDeclaration | <DIVIDE> NotDeclaration)*
;
NotDeclaration : DotArrayDeclaration | (<NOT> NotDeclaration)
;
DotArrayDeclaration : KeyWords (<DOT> DotDeclaration | <OPEN_SQUARE_BRACKET> AndDeclaration <CLOSE_SQUARE_BRACKET>)*
;

DotDeclaration : <LENGTH> | <IDENTIFIER> <OPEN_CURVE_BRACKET> [(AndDeclaration (<COMMA> AndDeclaration)*)]  <CLOSE_CURVE_BRACKET>
;

KeyWords :  <TRUE>  | 
            <FALSE> | 
            <THIS>  |
            NewDeclaration |
            <OPEN_CURVE_BRACKET> AndDeclaration <CLOSE_CURVE_BRACKET> |
            <IDENTIFIER> |
            <INTEGERLITERAL> 
;

NewDeclaration : <NEW> (<INT> <OPEN_SQUARE_BRACKET> AndDeclaration <CLOSE_SQUARE_BRACKET> | <IDENTIFIER> <OPEN_CURVE_BRACKET> <CLOSE_CURVE_BRACKET>)
;          





// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
        import pt.up.fe.comp.jmm.ast.JmmNode;
        import pt.up.fe.comp.jmm.ast.AJmmNode;
        import pt.up.fe.specs.util.SpecsCollections;
        extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}


SimpleNode Program():{}{
    ImportDeclaration() ClassDeclaration() <EOF> { return jjtThis; }
}

void ImportDeclaration():{Token t1, t2;}{
	(<IMPORT> t1 = <IDENTIFIER> {jjtThis.put("HEAD", t1.image)}; #Identifier(true) ( <DOT> t2 = <IDENTIFIER> {  jjtThis.put("NEXT", t2.image); } #Identifier)* <SEMICOLON>)*
}

void ClassDeclaration():{Token t1, t2;}{
	<Class> t1 = <IDENTIFIER> {jjtThis.put("CHILD", t1.image);} #Identifier [<EXTENDS> t2 = <IDENTIFIER> {jjtThis.put("PARENT", t2.image);} #Extends] <OPENBRACKET> ( VarDeclaration() )* (MethodDeclaration())* <CLOSEBRACKET>                            
}

void VarDeclaration():{Token t1;}{
	Type() t1 = <IDENTIFIER> {jjtThis.put("NAME", t1.image);} #Identifier <SEMICOLON>
}

void MethodDeclaration():{}{
	<PUBLIC> (CommonMethodHeader() | MainMethodHeader()) <OPENBRACKET> MethodBody() <CLOSEBRACKET>
}

void CommonMethodHeader():{Token t1, t2, t3;}{
	Type() t1 = <IDENTIFIER> {jjtThis.put("METHOD", t1.image);} #Identifier <OPEN_CURVE_BRACKET> [Type() t2 = <IDENTIFIER> {jjtThis.put("METHOD", t2.image);} #Identifier (<COMMA> Type() t3 = <IDENTIFIER> {jjtThis.put("METHOD", t3.image);} #Identifier)*] <CLOSE_CURVE_BRACKET>
}

void MainMethodHeader():{Token t1}{
	<STATIC> <VOID> <MAIN> <OPEN_CURVE_BRACKET> <STRING> <OPEN_SQUARE_BRACKET> <CLOSE_SQUARE_BRACKET> t1 = <IDENTIFIER> {jjtThis.put("METHOD", t1.image);} #Identifier <CLOSE_CURVE_BRACKET>
}

void MethodBody():{}{
	(VarDeclaration() | Statement())* <RETURN> AndDeclaration() <SEMICOLON>
}

void Statement():{}{
	<OPENBRACKET> (Statement())* <CLOSEBRACKET> |
        IfStatement() |
        WhileStatement() | 
        LOOKAHEAD(2) AndDeclaration() <SEMICOLON> |
        LOOKAHEAD(2) Assignment()
}

void IfStatement():{}{
	<IF> <OPEN_CURVE_BRACKET> AndDeclaration() <CLOSE_CURVE_BRACKET> Statement() <ELSE> Statement()
}

void WhileStatement():{}{
	<WHILE> <OPEN_CURVE_BRACKET> AndDeclaration() <CLOSE_CURVE_BRACKET> Statement()
}

void Assignment():{}{
	VarAccess() <EQUALS> AndDeclaration() <SEMICOLON>     
}

void VarAccess():{Token t1;}{
	LOOKAHEAD(2) t1 = <IDENTIFIER> {jjtThis.put("VAR", t1.image); } #Identifier <OPEN_SQUARE_BRACKET> AndDeclaration() <CLOSE_SQUARE_BRACKET> |
        LOOKAHEAD(2) t1 = <IDENTIFIER> {jjtThis.put("VAR", t1.image); } #Identifier
}

void AndDeclaration():{}{
	LessDeclaration() (<AND> LessDeclaration())*
}

void LessDeclaration():{}{
	AddSubDeclaration() (<LESS> AddSubDeclaration())*
}

void AddSubDeclaration():{}{
	MultDivDeclaration() (<PLUS> MultDivDeclaration() | <MINUS> MultDivDeclaration())*
}

void MultDivDeclaration():{}{
	NotDeclaration() (<TIMES> NotDeclaration() | <DIVIDE> NotDeclaration())*
}

void NotDeclaration():{}{
	DotArrayDeclaration() | (<NOT> NotDeclaration())
}

void DotArrayDeclaration():{}{
	KeyWords() (<DOT> DotDeclaration() | <OPEN_SQUARE_BRACKET> AndDeclaration() <CLOSE_SQUARE_BRACKET>)*
}

void DotDeclaration():{Token t1;}{
	<LENGTH> | t1 = <IDENTIFIER> {jjtThis.put("NAME", t1.image); } #Identifier <OPEN_CURVE_BRACKET> [(AndDeclaration() (<COMMA> AndDeclaration())*)]  <CLOSE_CURVE_BRACKET>
}

void KeyWords():{Token t1;}{
	<TRUE>  | 
        <FALSE> | 
        <THIS>  |
        NewDeclaration() |
        <OPEN_CURVE_BRACKET> AndDeclaration() <CLOSE_CURVE_BRACKET> |
        t1 = <IDENTIFIER> {jjtThis.put("NAME", t1.image); } #Identifier |
        t1 = <INTEGERLITERAL> {jjtThis.put("NUMBER", t1.image); } #Number
}

void NewDeclaration():{Token t1;}{
	<NEW> (<INT> <OPEN_SQUARE_BRACKET> AndDeclaration() <CLOSE_SQUARE_BRACKET> | t1 = <IDENTIFIER> {jjtThis.put("OBJECT", t1.image); } #Identifier | <OPEN_CURVE_BRACKET> <CLOSE_CURVE_BRACKET>)
}




