PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
		<IMPORT: "import">

    |   < INT: "int" >
    |   < BOOLEAN: "boolean" >
    |   < INTBRACKETS: "int[]">
    |   < STRING: "String" >

    |   < COMMA: "," >
    |   < DOT: ".">
    |   < COLON: ":" >
    |   < SEMICOLON: ";" >
    |   < OPENSQUAREBRACKET: "[">
    |   < CLOSESQUAREBRACKET: "]">
    |   < OPENCURVEBRACKET: "(">
    |   < CLOSECURVEBRACKET: ")">
    |   < OPENBRACKET: "{">
    |   < CLOSEBRACKET: "}">

    |   < CLASS: "class">
    |   < PUBLIC: "public">
    |   < STATIC: "static">
    |   < VOID: "void">
    |   < MAIN: "main">
    |   < PRINTLN: "System.out.println" >
    |   < THIS: "this" >
    |   < EXTENDS: "extends" >
    |   < RETURN: "return" >
    |   < LENGTH: "length">
    |   < NEW: "new">

    |   < TRUE: "true">
    |   < FALSE: "false">
    |   < NOT: "!">
    |   < AND: "&&">
    |   < LESS: "<" >
    |   < SUM: "+">
    |   < SUB: "-">
    |   < MULT: "*">
    |   < DIV: "/">
    |   < EQUALS: "=">


    |   < IF: "if">
    |   < ELSE: "else">
    |   < WHILE: "while">

    |   < IDENTIFIER:  ("$" | <LETTER>) ("_" | "$" | <LETTER> | <DIGIT> | <UNDERSCORE>)*
                     | ("_" ("_" | "$" | <LETTER> | <DIGIT> | <UNDERSCORE>)+) >
    |   < LETTER: ["a"-"z","A"-"Z"] >
    |   < UNDERSCORE: "_" >
    |   < INTEGERLITERAL: (<DIGIT>)+ >
    |   < DIGIT: ["0"-"9"] >
;

Start : AdditiveExpression <EOF> ;

AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	Factor
	(
		(< TIMES > | < DIVIDE >)
		Factor
	)?
;

Factor :
	< INTEGER > |
	< MINUS> Factor |
	< OPEN_PAREN > AdditiveExpression < CLOSE_PAREN >
;

//Fornecido pela UC

Program = ImportDeclaration, ClassDeclaration, EOF;


ImportDeclaration = {"import", Identifier, { ”.”, Identifier }, ";"}


ClassDeclaration = "class", Identifier, [ "extends", Identifier ], "{", { VarDeclaration }, { MethodDeclaration } "}";


VarDeclaration = Type, Identifier, ";";


MethodDeclaration = "public", Type, Identifier, "(", [ Type, Identifier, { ",", Type, Identifier }, ], ")", "{", { VarDeclaration }, { Statement }, "return", Expression, ";", "}"
|"public", "static", "void", "main", "(", "String", "[","]", Identifier, ")", "{", { VarDeclaration }, { Statement }, "}";


Type = "int", "[", "]"
| "boolean"
| "int"
| Identifier
;


Statement = "{", { Statement }, "}"
| "if", "(", Expression, ")", Statement, "else", Statement
| "while", "(", Expression, ")", Statement
| Expression, ";"
| Identifier, "=", Expression, ";"
| Identifier, "[", Expression, "]", "=", Expression, ";"
;


Expression = "true", NextExpression
| "true", NextExpression
| "false", NextExpression
| IntegerLiteral, NextExpression
| "new", Identifier ,"(" ,")", NextExpression
| Identifier, NextExpression

;


NextExpression = ( "&&" | "<" | "+" | "-" | "*" | "/") , NextExpression
| "[", NextExpression, "]"
| ".", "length"
| ".", Identifier, "(", [ Expression { ",", Expression } ], ")"
| "new", Identifier ,"(" ,")", NextExpression
| ?
;





Expression = Expression, ( "&&" | "<" | "+" | "-" | "*" | "/") , Expression
| Expression, "[", Expression, "]"
| Expression, ".", "length"
| Expression, ".", Identifier, "(", [ Expression { ",", Expression } ], ")"
| IntegerLiteral
| "true"
| "false"
| Identifier
| "this"
| "new", "int", "[", Expression, "]"
| "new", Identifier ,"(" ,")"
| "!", Expression
| "(", Expression, ")"
;

